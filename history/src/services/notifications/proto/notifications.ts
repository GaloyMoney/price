/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 0.0.0
 * source: notifications.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf"
import * as grpc_1 from "@grpc/grpc-js"

import * as dependency_1 from "./google/protobuf/struct"
export namespace services.notifications.v1 {
  export enum NotificationChannel {
    PUSH = 0,
  }
  export enum NotificationCategory {
    CIRCLES = 0,
    PAYMENTS = 1,
    BALANCE = 2,
    ADMIN_NOTIFICATION = 3,
  }
  export enum CircleType {
    INNER = 0,
    OUTER = 1,
  }
  export enum CircleTimeFrame {
    MONTH = 0,
    ALL_TIME = 1,
  }
  export enum DeclinedReason {
    DOCUMENTS_NOT_CLEAR = 0,
    VERIFICATION_PHOTO_NOT_CLEAR = 1,
    DOCUMENTS_NOT_SUPPORTED = 2,
    DOCUMENTS_EXPIRED = 3,
    DOCUMENTS_DO_NOT_MATCH = 4,
    OTHER = 5,
  }
  export class ShouldSendNotificationRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            channel?: NotificationChannel
            category?: NotificationCategory
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("channel" in data && data.channel != undefined) {
          this.channel = data.channel
        }
        if ("category" in data && data.category != undefined) {
          this.category = data.category
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get channel() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        NotificationChannel.PUSH,
      ) as NotificationChannel
    }
    set channel(value: NotificationChannel) {
      pb_1.Message.setField(this, 2, value)
    }
    get category() {
      return pb_1.Message.getFieldWithDefault(
        this,
        3,
        NotificationCategory.CIRCLES,
      ) as NotificationCategory
    }
    set category(value: NotificationCategory) {
      pb_1.Message.setField(this, 3, value)
    }
    static fromObject(data: {
      user_id?: string
      channel?: NotificationChannel
      category?: NotificationCategory
    }): ShouldSendNotificationRequest {
      const message = new ShouldSendNotificationRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.channel != null) {
        message.channel = data.channel
      }
      if (data.category != null) {
        message.category = data.category
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        channel?: NotificationChannel
        category?: NotificationCategory
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.channel != null) {
        data.channel = this.channel
      }
      if (this.category != null) {
        data.category = this.category
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.channel != NotificationChannel.PUSH) writer.writeEnum(2, this.channel)
      if (this.category != NotificationCategory.CIRCLES)
        writer.writeEnum(3, this.category)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): ShouldSendNotificationRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new ShouldSendNotificationRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.channel = reader.readEnum()
            break
          case 3:
            message.category = reader.readEnum()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): ShouldSendNotificationRequest {
      return ShouldSendNotificationRequest.deserialize(bytes)
    }
  }
  export class ShouldSendNotificationResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            should_send?: boolean
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("should_send" in data && data.should_send != undefined) {
          this.should_send = data.should_send
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get should_send() {
      return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean
    }
    set should_send(value: boolean) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      should_send?: boolean
    }): ShouldSendNotificationResponse {
      const message = new ShouldSendNotificationResponse({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.should_send != null) {
        message.should_send = data.should_send
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        should_send?: boolean
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.should_send != null) {
        data.should_send = this.should_send
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.should_send != false) writer.writeBool(2, this.should_send)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): ShouldSendNotificationResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new ShouldSendNotificationResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.should_send = reader.readBool()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): ShouldSendNotificationResponse {
      return ShouldSendNotificationResponse.deserialize(bytes)
    }
  }
  export class EnableNotificationChannelRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            channel?: NotificationChannel
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("channel" in data && data.channel != undefined) {
          this.channel = data.channel
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get channel() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        NotificationChannel.PUSH,
      ) as NotificationChannel
    }
    set channel(value: NotificationChannel) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      channel?: NotificationChannel
    }): EnableNotificationChannelRequest {
      const message = new EnableNotificationChannelRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.channel != null) {
        message.channel = data.channel
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        channel?: NotificationChannel
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.channel != null) {
        data.channel = this.channel
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.channel != NotificationChannel.PUSH) writer.writeEnum(2, this.channel)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): EnableNotificationChannelRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new EnableNotificationChannelRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.channel = reader.readEnum()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): EnableNotificationChannelRequest {
      return EnableNotificationChannelRequest.deserialize(bytes)
    }
  }
  export class EnableNotificationChannelResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): EnableNotificationChannelResponse {
      const message = new EnableNotificationChannelResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): EnableNotificationChannelResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new EnableNotificationChannelResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): EnableNotificationChannelResponse {
      return EnableNotificationChannelResponse.deserialize(bytes)
    }
  }
  export class NotificationSettings extends pb_1.Message {
    #one_of_decls: number[][] = [[2]]
    constructor(
      data?:
        | any[]
        | ({
            push?: ChannelNotificationSettings
            push_device_tokens?: string[]
          } & {
            locale?: string
          }),
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [3],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("push" in data && data.push != undefined) {
          this.push = data.push
        }
        if ("locale" in data && data.locale != undefined) {
          this.locale = data.locale
        }
        if ("push_device_tokens" in data && data.push_device_tokens != undefined) {
          this.push_device_tokens = data.push_device_tokens
        }
      }
    }
    get push() {
      return pb_1.Message.getWrapperField(
        this,
        ChannelNotificationSettings,
        1,
      ) as ChannelNotificationSettings
    }
    set push(value: ChannelNotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_push() {
      return pb_1.Message.getField(this, 1) != null
    }
    get locale() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string
    }
    set locale(value: string) {
      pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value)
    }
    get has_locale() {
      return pb_1.Message.getField(this, 2) != null
    }
    get push_device_tokens() {
      return pb_1.Message.getFieldWithDefault(this, 3, []) as string[]
    }
    set push_device_tokens(value: string[]) {
      pb_1.Message.setField(this, 3, value)
    }
    get _locale() {
      const cases: {
        [index: number]: "none" | "locale"
      } = {
        0: "none",
        2: "locale",
      }
      return cases[pb_1.Message.computeOneofCase(this, [2])]
    }
    static fromObject(data: {
      push?: ReturnType<typeof ChannelNotificationSettings.prototype.toObject>
      locale?: string
      push_device_tokens?: string[]
    }): NotificationSettings {
      const message = new NotificationSettings({})
      if (data.push != null) {
        message.push = ChannelNotificationSettings.fromObject(data.push)
      }
      if (data.locale != null) {
        message.locale = data.locale
      }
      if (data.push_device_tokens != null) {
        message.push_device_tokens = data.push_device_tokens
      }
      return message
    }
    toObject() {
      const data: {
        push?: ReturnType<typeof ChannelNotificationSettings.prototype.toObject>
        locale?: string
        push_device_tokens?: string[]
      } = {}
      if (this.push != null) {
        data.push = this.push.toObject()
      }
      if (this.locale != null) {
        data.locale = this.locale
      }
      if (this.push_device_tokens != null) {
        data.push_device_tokens = this.push_device_tokens
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_push)
        writer.writeMessage(1, this.push, () => this.push.serialize(writer))
      if (this.has_locale) writer.writeString(2, this.locale)
      if (this.push_device_tokens.length)
        writer.writeRepeatedString(3, this.push_device_tokens)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NotificationSettings {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new NotificationSettings()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.push,
              () => (message.push = ChannelNotificationSettings.deserialize(reader)),
            )
            break
          case 2:
            message.locale = reader.readString()
            break
          case 3:
            pb_1.Message.addToRepeatedField(message, 3, reader.readString())
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): NotificationSettings {
      return NotificationSettings.deserialize(bytes)
    }
  }
  export class ChannelNotificationSettings extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            enabled?: boolean
            disabled_categories?: NotificationCategory[]
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("enabled" in data && data.enabled != undefined) {
          this.enabled = data.enabled
        }
        if ("disabled_categories" in data && data.disabled_categories != undefined) {
          this.disabled_categories = data.disabled_categories
        }
      }
    }
    get enabled() {
      return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean
    }
    set enabled(value: boolean) {
      pb_1.Message.setField(this, 1, value)
    }
    get disabled_categories() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as NotificationCategory[]
    }
    set disabled_categories(value: NotificationCategory[]) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      enabled?: boolean
      disabled_categories?: NotificationCategory[]
    }): ChannelNotificationSettings {
      const message = new ChannelNotificationSettings({})
      if (data.enabled != null) {
        message.enabled = data.enabled
      }
      if (data.disabled_categories != null) {
        message.disabled_categories = data.disabled_categories
      }
      return message
    }
    toObject() {
      const data: {
        enabled?: boolean
        disabled_categories?: NotificationCategory[]
      } = {}
      if (this.enabled != null) {
        data.enabled = this.enabled
      }
      if (this.disabled_categories != null) {
        data.disabled_categories = this.disabled_categories
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.enabled != false) writer.writeBool(1, this.enabled)
      if (this.disabled_categories.length)
        writer.writePackedEnum(2, this.disabled_categories)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): ChannelNotificationSettings {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new ChannelNotificationSettings()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.enabled = reader.readBool()
            break
          case 2:
            message.disabled_categories = reader.readPackedEnum()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): ChannelNotificationSettings {
      return ChannelNotificationSettings.deserialize(bytes)
    }
  }
  export class DisableNotificationChannelRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            channel?: NotificationChannel
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("channel" in data && data.channel != undefined) {
          this.channel = data.channel
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get channel() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        NotificationChannel.PUSH,
      ) as NotificationChannel
    }
    set channel(value: NotificationChannel) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      channel?: NotificationChannel
    }): DisableNotificationChannelRequest {
      const message = new DisableNotificationChannelRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.channel != null) {
        message.channel = data.channel
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        channel?: NotificationChannel
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.channel != null) {
        data.channel = this.channel
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.channel != NotificationChannel.PUSH) writer.writeEnum(2, this.channel)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): DisableNotificationChannelRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new DisableNotificationChannelRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.channel = reader.readEnum()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): DisableNotificationChannelRequest {
      return DisableNotificationChannelRequest.deserialize(bytes)
    }
  }
  export class DisableNotificationChannelResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): DisableNotificationChannelResponse {
      const message = new DisableNotificationChannelResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): DisableNotificationChannelResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new DisableNotificationChannelResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): DisableNotificationChannelResponse {
      return DisableNotificationChannelResponse.deserialize(bytes)
    }
  }
  export class DisableNotificationCategoryRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            channel?: NotificationChannel
            category?: NotificationCategory
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("channel" in data && data.channel != undefined) {
          this.channel = data.channel
        }
        if ("category" in data && data.category != undefined) {
          this.category = data.category
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get channel() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        NotificationChannel.PUSH,
      ) as NotificationChannel
    }
    set channel(value: NotificationChannel) {
      pb_1.Message.setField(this, 2, value)
    }
    get category() {
      return pb_1.Message.getFieldWithDefault(
        this,
        3,
        NotificationCategory.CIRCLES,
      ) as NotificationCategory
    }
    set category(value: NotificationCategory) {
      pb_1.Message.setField(this, 3, value)
    }
    static fromObject(data: {
      user_id?: string
      channel?: NotificationChannel
      category?: NotificationCategory
    }): DisableNotificationCategoryRequest {
      const message = new DisableNotificationCategoryRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.channel != null) {
        message.channel = data.channel
      }
      if (data.category != null) {
        message.category = data.category
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        channel?: NotificationChannel
        category?: NotificationCategory
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.channel != null) {
        data.channel = this.channel
      }
      if (this.category != null) {
        data.category = this.category
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.channel != NotificationChannel.PUSH) writer.writeEnum(2, this.channel)
      if (this.category != NotificationCategory.CIRCLES)
        writer.writeEnum(3, this.category)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): DisableNotificationCategoryRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new DisableNotificationCategoryRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.channel = reader.readEnum()
            break
          case 3:
            message.category = reader.readEnum()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): DisableNotificationCategoryRequest {
      return DisableNotificationCategoryRequest.deserialize(bytes)
    }
  }
  export class DisableNotificationCategoryResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): DisableNotificationCategoryResponse {
      const message = new DisableNotificationCategoryResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): DisableNotificationCategoryResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new DisableNotificationCategoryResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): DisableNotificationCategoryResponse {
      return DisableNotificationCategoryResponse.deserialize(bytes)
    }
  }
  export class EnableNotificationCategoryRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            channel?: NotificationChannel
            category?: NotificationCategory
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("channel" in data && data.channel != undefined) {
          this.channel = data.channel
        }
        if ("category" in data && data.category != undefined) {
          this.category = data.category
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get channel() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        NotificationChannel.PUSH,
      ) as NotificationChannel
    }
    set channel(value: NotificationChannel) {
      pb_1.Message.setField(this, 2, value)
    }
    get category() {
      return pb_1.Message.getFieldWithDefault(
        this,
        3,
        NotificationCategory.CIRCLES,
      ) as NotificationCategory
    }
    set category(value: NotificationCategory) {
      pb_1.Message.setField(this, 3, value)
    }
    static fromObject(data: {
      user_id?: string
      channel?: NotificationChannel
      category?: NotificationCategory
    }): EnableNotificationCategoryRequest {
      const message = new EnableNotificationCategoryRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.channel != null) {
        message.channel = data.channel
      }
      if (data.category != null) {
        message.category = data.category
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        channel?: NotificationChannel
        category?: NotificationCategory
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.channel != null) {
        data.channel = this.channel
      }
      if (this.category != null) {
        data.category = this.category
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.channel != NotificationChannel.PUSH) writer.writeEnum(2, this.channel)
      if (this.category != NotificationCategory.CIRCLES)
        writer.writeEnum(3, this.category)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): EnableNotificationCategoryRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new EnableNotificationCategoryRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.channel = reader.readEnum()
            break
          case 3:
            message.category = reader.readEnum()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): EnableNotificationCategoryRequest {
      return EnableNotificationCategoryRequest.deserialize(bytes)
    }
  }
  export class EnableNotificationCategoryResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): EnableNotificationCategoryResponse {
      const message = new EnableNotificationCategoryResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): EnableNotificationCategoryResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new EnableNotificationCategoryResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): EnableNotificationCategoryResponse {
      return EnableNotificationCategoryResponse.deserialize(bytes)
    }
  }
  export class GetNotificationSettingsRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    static fromObject(data: { user_id?: string }): GetNotificationSettingsRequest {
      const message = new GetNotificationSettingsRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): GetNotificationSettingsRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new GetNotificationSettingsRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): GetNotificationSettingsRequest {
      return GetNotificationSettingsRequest.deserialize(bytes)
    }
  }
  export class GetNotificationSettingsResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): GetNotificationSettingsResponse {
      const message = new GetNotificationSettingsResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): GetNotificationSettingsResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new GetNotificationSettingsResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): GetNotificationSettingsResponse {
      return GetNotificationSettingsResponse.deserialize(bytes)
    }
  }
  export class UpdateUserLocaleRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            locale?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("locale" in data && data.locale != undefined) {
          this.locale = data.locale
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get locale() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string
    }
    set locale(value: string) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      locale?: string
    }): UpdateUserLocaleRequest {
      const message = new UpdateUserLocaleRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.locale != null) {
        message.locale = data.locale
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        locale?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.locale != null) {
        data.locale = this.locale
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.locale.length) writer.writeString(2, this.locale)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateUserLocaleRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new UpdateUserLocaleRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.locale = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): UpdateUserLocaleRequest {
      return UpdateUserLocaleRequest.deserialize(bytes)
    }
  }
  export class UpdateUserLocaleResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): UpdateUserLocaleResponse {
      const message = new UpdateUserLocaleResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateUserLocaleResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new UpdateUserLocaleResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): UpdateUserLocaleResponse {
      return UpdateUserLocaleResponse.deserialize(bytes)
    }
  }
  export class AddPushDeviceTokenRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            device_token?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("device_token" in data && data.device_token != undefined) {
          this.device_token = data.device_token
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get device_token() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string
    }
    set device_token(value: string) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      device_token?: string
    }): AddPushDeviceTokenRequest {
      const message = new AddPushDeviceTokenRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.device_token != null) {
        message.device_token = data.device_token
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        device_token?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.device_token != null) {
        data.device_token = this.device_token
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.device_token.length) writer.writeString(2, this.device_token)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AddPushDeviceTokenRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new AddPushDeviceTokenRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.device_token = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): AddPushDeviceTokenRequest {
      return AddPushDeviceTokenRequest.deserialize(bytes)
    }
  }
  export class AddPushDeviceTokenResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): AddPushDeviceTokenResponse {
      const message = new AddPushDeviceTokenResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): AddPushDeviceTokenResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new AddPushDeviceTokenResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): AddPushDeviceTokenResponse {
      return AddPushDeviceTokenResponse.deserialize(bytes)
    }
  }
  export class RemovePushDeviceTokenRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            device_token?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("device_token" in data && data.device_token != undefined) {
          this.device_token = data.device_token
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get device_token() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string
    }
    set device_token(value: string) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      device_token?: string
    }): RemovePushDeviceTokenRequest {
      const message = new RemovePushDeviceTokenRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.device_token != null) {
        message.device_token = data.device_token
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        device_token?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.device_token != null) {
        data.device_token = this.device_token
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.device_token.length) writer.writeString(2, this.device_token)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): RemovePushDeviceTokenRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new RemovePushDeviceTokenRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.device_token = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): RemovePushDeviceTokenRequest {
      return RemovePushDeviceTokenRequest.deserialize(bytes)
    }
  }
  export class RemovePushDeviceTokenResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            notification_settings?: NotificationSettings
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("notification_settings" in data && data.notification_settings != undefined) {
          this.notification_settings = data.notification_settings
        }
      }
    }
    get notification_settings() {
      return pb_1.Message.getWrapperField(
        this,
        NotificationSettings,
        1,
      ) as NotificationSettings
    }
    set notification_settings(value: NotificationSettings) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_notification_settings() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
    }): RemovePushDeviceTokenResponse {
      const message = new RemovePushDeviceTokenResponse({})
      if (data.notification_settings != null) {
        message.notification_settings = NotificationSettings.fromObject(
          data.notification_settings,
        )
      }
      return message
    }
    toObject() {
      const data: {
        notification_settings?: ReturnType<typeof NotificationSettings.prototype.toObject>
      } = {}
      if (this.notification_settings != null) {
        data.notification_settings = this.notification_settings.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_notification_settings)
        writer.writeMessage(1, this.notification_settings, () =>
          this.notification_settings.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): RemovePushDeviceTokenResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new RemovePushDeviceTokenResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.notification_settings,
              () =>
                (message.notification_settings =
                  NotificationSettings.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): RemovePushDeviceTokenResponse {
      return RemovePushDeviceTokenResponse.deserialize(bytes)
    }
  }
  export class UpdateEmailAddressRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            email_address?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("email_address" in data && data.email_address != undefined) {
          this.email_address = data.email_address
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get email_address() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string
    }
    set email_address(value: string) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      email_address?: string
    }): UpdateEmailAddressRequest {
      const message = new UpdateEmailAddressRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.email_address != null) {
        message.email_address = data.email_address
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        email_address?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.email_address != null) {
        data.email_address = this.email_address
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.email_address.length) writer.writeString(2, this.email_address)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateEmailAddressRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new UpdateEmailAddressRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.email_address = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): UpdateEmailAddressRequest {
      return UpdateEmailAddressRequest.deserialize(bytes)
    }
  }
  export class UpdateEmailAddressResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(data?: any[] | {}) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): UpdateEmailAddressResponse {
      const message = new UpdateEmailAddressResponse({})
      return message
    }
    toObject() {
      const data: {} = {}
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): UpdateEmailAddressResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new UpdateEmailAddressResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): UpdateEmailAddressResponse {
      return UpdateEmailAddressResponse.deserialize(bytes)
    }
  }
  export class RemoveEmailAddressRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    static fromObject(data: { user_id?: string }): RemoveEmailAddressRequest {
      const message = new RemoveEmailAddressRequest({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RemoveEmailAddressRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new RemoveEmailAddressRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): RemoveEmailAddressRequest {
      return RemoveEmailAddressRequest.deserialize(bytes)
    }
  }
  export class RemoveEmailAddressResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(data?: any[] | {}) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): RemoveEmailAddressResponse {
      const message = new RemoveEmailAddressResponse({})
      return message
    }
    toObject() {
      const data: {} = {}
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): RemoveEmailAddressResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new RemoveEmailAddressResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): RemoveEmailAddressResponse {
      return RemoveEmailAddressResponse.deserialize(bytes)
    }
  }
  export class HandleNotificationEventRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            event?: NotificationEvent
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("event" in data && data.event != undefined) {
          this.event = data.event
        }
      }
    }
    get event() {
      return pb_1.Message.getWrapperField(this, NotificationEvent, 1) as NotificationEvent
    }
    set event(value: NotificationEvent) {
      pb_1.Message.setWrapperField(this, 1, value)
    }
    get has_event() {
      return pb_1.Message.getField(this, 1) != null
    }
    static fromObject(data: {
      event?: ReturnType<typeof NotificationEvent.prototype.toObject>
    }): HandleNotificationEventRequest {
      const message = new HandleNotificationEventRequest({})
      if (data.event != null) {
        message.event = NotificationEvent.fromObject(data.event)
      }
      return message
    }
    toObject() {
      const data: {
        event?: ReturnType<typeof NotificationEvent.prototype.toObject>
      } = {}
      if (this.event != null) {
        data.event = this.event.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_event)
        writer.writeMessage(1, this.event, () => this.event.serialize(writer))
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): HandleNotificationEventRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new HandleNotificationEventRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.event,
              () => (message.event = NotificationEvent.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): HandleNotificationEventRequest {
      return HandleNotificationEventRequest.deserialize(bytes)
    }
  }
  export class HandleNotificationEventResponse extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(data?: any[] | {}) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
      }
    }
    static fromObject(data: {}): HandleNotificationEventResponse {
      const message = new HandleNotificationEventResponse({})
      return message
    }
    toObject() {
      const data: {} = {}
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): HandleNotificationEventResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new HandleNotificationEventResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): HandleNotificationEventResponse {
      return HandleNotificationEventResponse.deserialize(bytes)
    }
  }
  export class NotificationEvent extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2, 3, 4, 5]]
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                circle_grew?: CircleGrew
                circle_threshold_reached?: never
                identity_verification_approved?: never
                identity_verification_declined?: never
                identity_verification_review_started?: never
              }
            | {
                circle_grew?: never
                circle_threshold_reached?: CircleThresholdReached
                identity_verification_approved?: never
                identity_verification_declined?: never
                identity_verification_review_started?: never
              }
            | {
                circle_grew?: never
                circle_threshold_reached?: never
                identity_verification_approved?: IdentityVerificationApproved
                identity_verification_declined?: never
                identity_verification_review_started?: never
              }
            | {
                circle_grew?: never
                circle_threshold_reached?: never
                identity_verification_approved?: never
                identity_verification_declined?: IdentityVerificationDeclined
                identity_verification_review_started?: never
              }
            | {
                circle_grew?: never
                circle_threshold_reached?: never
                identity_verification_approved?: never
                identity_verification_declined?: never
                identity_verification_review_started?: IdentityVerificationReviewStarted
              }
          )),
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("circle_grew" in data && data.circle_grew != undefined) {
          this.circle_grew = data.circle_grew
        }
        if (
          "circle_threshold_reached" in data &&
          data.circle_threshold_reached != undefined
        ) {
          this.circle_threshold_reached = data.circle_threshold_reached
        }
        if (
          "identity_verification_approved" in data &&
          data.identity_verification_approved != undefined
        ) {
          this.identity_verification_approved = data.identity_verification_approved
        }
        if (
          "identity_verification_declined" in data &&
          data.identity_verification_declined != undefined
        ) {
          this.identity_verification_declined = data.identity_verification_declined
        }
        if (
          "identity_verification_review_started" in data &&
          data.identity_verification_review_started != undefined
        ) {
          this.identity_verification_review_started =
            data.identity_verification_review_started
        }
      }
    }
    get circle_grew() {
      return pb_1.Message.getWrapperField(this, CircleGrew, 1) as CircleGrew
    }
    set circle_grew(value: CircleGrew) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value)
    }
    get has_circle_grew() {
      return pb_1.Message.getField(this, 1) != null
    }
    get circle_threshold_reached() {
      return pb_1.Message.getWrapperField(
        this,
        CircleThresholdReached,
        2,
      ) as CircleThresholdReached
    }
    set circle_threshold_reached(value: CircleThresholdReached) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value)
    }
    get has_circle_threshold_reached() {
      return pb_1.Message.getField(this, 2) != null
    }
    get identity_verification_approved() {
      return pb_1.Message.getWrapperField(
        this,
        IdentityVerificationApproved,
        3,
      ) as IdentityVerificationApproved
    }
    set identity_verification_approved(value: IdentityVerificationApproved) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value)
    }
    get has_identity_verification_approved() {
      return pb_1.Message.getField(this, 3) != null
    }
    get identity_verification_declined() {
      return pb_1.Message.getWrapperField(
        this,
        IdentityVerificationDeclined,
        4,
      ) as IdentityVerificationDeclined
    }
    set identity_verification_declined(value: IdentityVerificationDeclined) {
      pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value)
    }
    get has_identity_verification_declined() {
      return pb_1.Message.getField(this, 4) != null
    }
    get identity_verification_review_started() {
      return pb_1.Message.getWrapperField(
        this,
        IdentityVerificationReviewStarted,
        5,
      ) as IdentityVerificationReviewStarted
    }
    set identity_verification_review_started(value: IdentityVerificationReviewStarted) {
      pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value)
    }
    get has_identity_verification_review_started() {
      return pb_1.Message.getField(this, 5) != null
    }
    get data() {
      const cases: {
        [index: number]:
          | "none"
          | "circle_grew"
          | "circle_threshold_reached"
          | "identity_verification_approved"
          | "identity_verification_declined"
          | "identity_verification_review_started"
      } = {
        0: "none",
        1: "circle_grew",
        2: "circle_threshold_reached",
        3: "identity_verification_approved",
        4: "identity_verification_declined",
        5: "identity_verification_review_started",
      }
      return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5])]
    }
    static fromObject(data: {
      circle_grew?: ReturnType<typeof CircleGrew.prototype.toObject>
      circle_threshold_reached?: ReturnType<
        typeof CircleThresholdReached.prototype.toObject
      >
      identity_verification_approved?: ReturnType<
        typeof IdentityVerificationApproved.prototype.toObject
      >
      identity_verification_declined?: ReturnType<
        typeof IdentityVerificationDeclined.prototype.toObject
      >
      identity_verification_review_started?: ReturnType<
        typeof IdentityVerificationReviewStarted.prototype.toObject
      >
    }): NotificationEvent {
      const message = new NotificationEvent({})
      if (data.circle_grew != null) {
        message.circle_grew = CircleGrew.fromObject(data.circle_grew)
      }
      if (data.circle_threshold_reached != null) {
        message.circle_threshold_reached = CircleThresholdReached.fromObject(
          data.circle_threshold_reached,
        )
      }
      if (data.identity_verification_approved != null) {
        message.identity_verification_approved = IdentityVerificationApproved.fromObject(
          data.identity_verification_approved,
        )
      }
      if (data.identity_verification_declined != null) {
        message.identity_verification_declined = IdentityVerificationDeclined.fromObject(
          data.identity_verification_declined,
        )
      }
      if (data.identity_verification_review_started != null) {
        message.identity_verification_review_started =
          IdentityVerificationReviewStarted.fromObject(
            data.identity_verification_review_started,
          )
      }
      return message
    }
    toObject() {
      const data: {
        circle_grew?: ReturnType<typeof CircleGrew.prototype.toObject>
        circle_threshold_reached?: ReturnType<
          typeof CircleThresholdReached.prototype.toObject
        >
        identity_verification_approved?: ReturnType<
          typeof IdentityVerificationApproved.prototype.toObject
        >
        identity_verification_declined?: ReturnType<
          typeof IdentityVerificationDeclined.prototype.toObject
        >
        identity_verification_review_started?: ReturnType<
          typeof IdentityVerificationReviewStarted.prototype.toObject
        >
      } = {}
      if (this.circle_grew != null) {
        data.circle_grew = this.circle_grew.toObject()
      }
      if (this.circle_threshold_reached != null) {
        data.circle_threshold_reached = this.circle_threshold_reached.toObject()
      }
      if (this.identity_verification_approved != null) {
        data.identity_verification_approved =
          this.identity_verification_approved.toObject()
      }
      if (this.identity_verification_declined != null) {
        data.identity_verification_declined =
          this.identity_verification_declined.toObject()
      }
      if (this.identity_verification_review_started != null) {
        data.identity_verification_review_started =
          this.identity_verification_review_started.toObject()
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_circle_grew)
        writer.writeMessage(1, this.circle_grew, () => this.circle_grew.serialize(writer))
      if (this.has_circle_threshold_reached)
        writer.writeMessage(2, this.circle_threshold_reached, () =>
          this.circle_threshold_reached.serialize(writer),
        )
      if (this.has_identity_verification_approved)
        writer.writeMessage(3, this.identity_verification_approved, () =>
          this.identity_verification_approved.serialize(writer),
        )
      if (this.has_identity_verification_declined)
        writer.writeMessage(4, this.identity_verification_declined, () =>
          this.identity_verification_declined.serialize(writer),
        )
      if (this.has_identity_verification_review_started)
        writer.writeMessage(5, this.identity_verification_review_started, () =>
          this.identity_verification_review_started.serialize(writer),
        )
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NotificationEvent {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new NotificationEvent()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.circle_grew,
              () => (message.circle_grew = CircleGrew.deserialize(reader)),
            )
            break
          case 2:
            reader.readMessage(
              message.circle_threshold_reached,
              () =>
                (message.circle_threshold_reached =
                  CircleThresholdReached.deserialize(reader)),
            )
            break
          case 3:
            reader.readMessage(
              message.identity_verification_approved,
              () =>
                (message.identity_verification_approved =
                  IdentityVerificationApproved.deserialize(reader)),
            )
            break
          case 4:
            reader.readMessage(
              message.identity_verification_declined,
              () =>
                (message.identity_verification_declined =
                  IdentityVerificationDeclined.deserialize(reader)),
            )
            break
          case 5:
            reader.readMessage(
              message.identity_verification_review_started,
              () =>
                (message.identity_verification_review_started =
                  IdentityVerificationReviewStarted.deserialize(reader)),
            )
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): NotificationEvent {
      return NotificationEvent.deserialize(bytes)
    }
  }
  export class CircleGrew extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            circle_type?: CircleType
            this_month_circle_size?: number
            all_time_circle_size?: number
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("circle_type" in data && data.circle_type != undefined) {
          this.circle_type = data.circle_type
        }
        if (
          "this_month_circle_size" in data &&
          data.this_month_circle_size != undefined
        ) {
          this.this_month_circle_size = data.this_month_circle_size
        }
        if ("all_time_circle_size" in data && data.all_time_circle_size != undefined) {
          this.all_time_circle_size = data.all_time_circle_size
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get circle_type() {
      return pb_1.Message.getFieldWithDefault(this, 2, CircleType.INNER) as CircleType
    }
    set circle_type(value: CircleType) {
      pb_1.Message.setField(this, 2, value)
    }
    get this_month_circle_size() {
      return pb_1.Message.getFieldWithDefault(this, 3, 0) as number
    }
    set this_month_circle_size(value: number) {
      pb_1.Message.setField(this, 3, value)
    }
    get all_time_circle_size() {
      return pb_1.Message.getFieldWithDefault(this, 4, 0) as number
    }
    set all_time_circle_size(value: number) {
      pb_1.Message.setField(this, 4, value)
    }
    static fromObject(data: {
      user_id?: string
      circle_type?: CircleType
      this_month_circle_size?: number
      all_time_circle_size?: number
    }): CircleGrew {
      const message = new CircleGrew({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.circle_type != null) {
        message.circle_type = data.circle_type
      }
      if (data.this_month_circle_size != null) {
        message.this_month_circle_size = data.this_month_circle_size
      }
      if (data.all_time_circle_size != null) {
        message.all_time_circle_size = data.all_time_circle_size
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        circle_type?: CircleType
        this_month_circle_size?: number
        all_time_circle_size?: number
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.circle_type != null) {
        data.circle_type = this.circle_type
      }
      if (this.this_month_circle_size != null) {
        data.this_month_circle_size = this.this_month_circle_size
      }
      if (this.all_time_circle_size != null) {
        data.all_time_circle_size = this.all_time_circle_size
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.circle_type != CircleType.INNER) writer.writeEnum(2, this.circle_type)
      if (this.this_month_circle_size != 0)
        writer.writeUint32(3, this.this_month_circle_size)
      if (this.all_time_circle_size != 0) writer.writeUint32(4, this.all_time_circle_size)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CircleGrew {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new CircleGrew()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.circle_type = reader.readEnum()
            break
          case 3:
            message.this_month_circle_size = reader.readUint32()
            break
          case 4:
            message.all_time_circle_size = reader.readUint32()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): CircleGrew {
      return CircleGrew.deserialize(bytes)
    }
  }
  export class CircleThresholdReached extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            circle_type?: CircleType
            time_frame?: CircleTimeFrame
            threshold?: number
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("circle_type" in data && data.circle_type != undefined) {
          this.circle_type = data.circle_type
        }
        if ("time_frame" in data && data.time_frame != undefined) {
          this.time_frame = data.time_frame
        }
        if ("threshold" in data && data.threshold != undefined) {
          this.threshold = data.threshold
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get circle_type() {
      return pb_1.Message.getFieldWithDefault(this, 2, CircleType.INNER) as CircleType
    }
    set circle_type(value: CircleType) {
      pb_1.Message.setField(this, 2, value)
    }
    get time_frame() {
      return pb_1.Message.getFieldWithDefault(
        this,
        3,
        CircleTimeFrame.MONTH,
      ) as CircleTimeFrame
    }
    set time_frame(value: CircleTimeFrame) {
      pb_1.Message.setField(this, 3, value)
    }
    get threshold() {
      return pb_1.Message.getFieldWithDefault(this, 4, 0) as number
    }
    set threshold(value: number) {
      pb_1.Message.setField(this, 4, value)
    }
    static fromObject(data: {
      user_id?: string
      circle_type?: CircleType
      time_frame?: CircleTimeFrame
      threshold?: number
    }): CircleThresholdReached {
      const message = new CircleThresholdReached({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.circle_type != null) {
        message.circle_type = data.circle_type
      }
      if (data.time_frame != null) {
        message.time_frame = data.time_frame
      }
      if (data.threshold != null) {
        message.threshold = data.threshold
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        circle_type?: CircleType
        time_frame?: CircleTimeFrame
        threshold?: number
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.circle_type != null) {
        data.circle_type = this.circle_type
      }
      if (this.time_frame != null) {
        data.time_frame = this.time_frame
      }
      if (this.threshold != null) {
        data.threshold = this.threshold
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.circle_type != CircleType.INNER) writer.writeEnum(2, this.circle_type)
      if (this.time_frame != CircleTimeFrame.MONTH) writer.writeEnum(3, this.time_frame)
      if (this.threshold != 0) writer.writeUint32(4, this.threshold)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CircleThresholdReached {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new CircleThresholdReached()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.circle_type = reader.readEnum()
            break
          case 3:
            message.time_frame = reader.readEnum()
            break
          case 4:
            message.threshold = reader.readUint32()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): CircleThresholdReached {
      return CircleThresholdReached.deserialize(bytes)
    }
  }
  export class IdentityVerificationApproved extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    static fromObject(data: { user_id?: string }): IdentityVerificationApproved {
      const message = new IdentityVerificationApproved({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): IdentityVerificationApproved {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new IdentityVerificationApproved()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): IdentityVerificationApproved {
      return IdentityVerificationApproved.deserialize(bytes)
    }
  }
  export class IdentityVerificationDeclined extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
            declined_reason?: DeclinedReason
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
        if ("declined_reason" in data && data.declined_reason != undefined) {
          this.declined_reason = data.declined_reason
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get declined_reason() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        DeclinedReason.DOCUMENTS_NOT_CLEAR,
      ) as DeclinedReason
    }
    set declined_reason(value: DeclinedReason) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: {
      user_id?: string
      declined_reason?: DeclinedReason
    }): IdentityVerificationDeclined {
      const message = new IdentityVerificationDeclined({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      if (data.declined_reason != null) {
        message.declined_reason = data.declined_reason
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
        declined_reason?: DeclinedReason
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      if (this.declined_reason != null) {
        data.declined_reason = this.declined_reason
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (this.declined_reason != DeclinedReason.DOCUMENTS_NOT_CLEAR)
        writer.writeEnum(2, this.declined_reason)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): IdentityVerificationDeclined {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new IdentityVerificationDeclined()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          case 2:
            message.declined_reason = reader.readEnum()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): IdentityVerificationDeclined {
      return IdentityVerificationDeclined.deserialize(bytes)
    }
  }
  export class IdentityVerificationReviewStarted extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            user_id?: string
          },
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      )
      if (!Array.isArray(data) && typeof data == "object") {
        if ("user_id" in data && data.user_id != undefined) {
          this.user_id = data.user_id
        }
      }
    }
    get user_id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string
    }
    set user_id(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    static fromObject(data: { user_id?: string }): IdentityVerificationReviewStarted {
      const message = new IdentityVerificationReviewStarted({})
      if (data.user_id != null) {
        message.user_id = data.user_id
      }
      return message
    }
    toObject() {
      const data: {
        user_id?: string
      } = {}
      if (this.user_id != null) {
        data.user_id = this.user_id
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.user_id.length) writer.writeString(1, this.user_id)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): IdentityVerificationReviewStarted {
      const reader =
          bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new IdentityVerificationReviewStarted()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.user_id = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): IdentityVerificationReviewStarted {
      return IdentityVerificationReviewStarted.deserialize(bytes)
    }
  }
  interface GrpcUnaryServiceInterface<P, R> {
    (
      message: P,
      metadata: grpc_1.Metadata,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>,
    ): grpc_1.ClientUnaryCall
    (
      message: P,
      metadata: grpc_1.Metadata,
      callback: grpc_1.requestCallback<R>,
    ): grpc_1.ClientUnaryCall
    (
      message: P,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>,
    ): grpc_1.ClientUnaryCall
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall
  }
  interface GrpcStreamServiceInterface<P, R> {
    (
      message: P,
      metadata: grpc_1.Metadata,
      options?: grpc_1.CallOptions,
    ): grpc_1.ClientReadableStream<R>
    (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>
  }
  interface GrpWritableServiceInterface<P, R> {
    (
      metadata: grpc_1.Metadata,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>,
    ): grpc_1.ClientWritableStream<P>
    (
      metadata: grpc_1.Metadata,
      callback: grpc_1.requestCallback<R>,
    ): grpc_1.ClientWritableStream<P>
    (
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>,
    ): grpc_1.ClientWritableStream<P>
    (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>
  }
  interface GrpcChunkServiceInterface<P, R> {
    (
      metadata: grpc_1.Metadata,
      options?: grpc_1.CallOptions,
    ): grpc_1.ClientDuplexStream<P, R>
    (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>
  }
  interface GrpcPromiseServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>
    (message: P, options?: grpc_1.CallOptions): Promise<R>
  }
  export abstract class UnimplementedNotificationsServiceService {
    static definition = {
      ShouldSendNotification: {
        path: "/services.notifications.v1.NotificationsService/ShouldSendNotification",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: ShouldSendNotificationRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          ShouldSendNotificationRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: ShouldSendNotificationResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          ShouldSendNotificationResponse.deserialize(new Uint8Array(bytes)),
      },
      EnableNotificationChannel: {
        path: "/services.notifications.v1.NotificationsService/EnableNotificationChannel",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: EnableNotificationChannelRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          EnableNotificationChannelRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: EnableNotificationChannelResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          EnableNotificationChannelResponse.deserialize(new Uint8Array(bytes)),
      },
      DisableNotificationChannel: {
        path: "/services.notifications.v1.NotificationsService/DisableNotificationChannel",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: DisableNotificationChannelRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          DisableNotificationChannelRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: DisableNotificationChannelResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          DisableNotificationChannelResponse.deserialize(new Uint8Array(bytes)),
      },
      EnableNotificationCategory: {
        path: "/services.notifications.v1.NotificationsService/EnableNotificationCategory",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: EnableNotificationCategoryRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          EnableNotificationCategoryRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: EnableNotificationCategoryResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          EnableNotificationCategoryResponse.deserialize(new Uint8Array(bytes)),
      },
      DisableNotificationCategory: {
        path: "/services.notifications.v1.NotificationsService/DisableNotificationCategory",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: DisableNotificationCategoryRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          DisableNotificationCategoryRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: DisableNotificationCategoryResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          DisableNotificationCategoryResponse.deserialize(new Uint8Array(bytes)),
      },
      GetNotificationSettings: {
        path: "/services.notifications.v1.NotificationsService/GetNotificationSettings",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: GetNotificationSettingsRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          GetNotificationSettingsRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: GetNotificationSettingsResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          GetNotificationSettingsResponse.deserialize(new Uint8Array(bytes)),
      },
      UpdateUserLocale: {
        path: "/services.notifications.v1.NotificationsService/UpdateUserLocale",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: UpdateUserLocaleRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          UpdateUserLocaleRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: UpdateUserLocaleResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          UpdateUserLocaleResponse.deserialize(new Uint8Array(bytes)),
      },
      AddPushDeviceToken: {
        path: "/services.notifications.v1.NotificationsService/AddPushDeviceToken",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: AddPushDeviceTokenRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          AddPushDeviceTokenRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: AddPushDeviceTokenResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          AddPushDeviceTokenResponse.deserialize(new Uint8Array(bytes)),
      },
      RemovePushDeviceToken: {
        path: "/services.notifications.v1.NotificationsService/RemovePushDeviceToken",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: RemovePushDeviceTokenRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          RemovePushDeviceTokenRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: RemovePushDeviceTokenResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          RemovePushDeviceTokenResponse.deserialize(new Uint8Array(bytes)),
      },
      UpdateEmailAddress: {
        path: "/services.notifications.v1.NotificationsService/UpdateEmailAddress",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: UpdateEmailAddressRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          UpdateEmailAddressRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: UpdateEmailAddressResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          UpdateEmailAddressResponse.deserialize(new Uint8Array(bytes)),
      },
      RemoveEmailAddress: {
        path: "/services.notifications.v1.NotificationsService/RemoveEmailAddress",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: RemoveEmailAddressRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          RemoveEmailAddressRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: RemoveEmailAddressResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          RemoveEmailAddressResponse.deserialize(new Uint8Array(bytes)),
      },
      HandleNotificationEvent: {
        path: "/services.notifications.v1.NotificationsService/HandleNotificationEvent",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: HandleNotificationEventRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          HandleNotificationEventRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: HandleNotificationEventResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          HandleNotificationEventResponse.deserialize(new Uint8Array(bytes)),
      },
    };
    [method: string]: grpc_1.UntypedHandleCall
    abstract ShouldSendNotification(
      call: grpc_1.ServerUnaryCall<
        ShouldSendNotificationRequest,
        ShouldSendNotificationResponse
      >,
      callback: grpc_1.sendUnaryData<ShouldSendNotificationResponse>,
    ): void
    abstract EnableNotificationChannel(
      call: grpc_1.ServerUnaryCall<
        EnableNotificationChannelRequest,
        EnableNotificationChannelResponse
      >,
      callback: grpc_1.sendUnaryData<EnableNotificationChannelResponse>,
    ): void
    abstract DisableNotificationChannel(
      call: grpc_1.ServerUnaryCall<
        DisableNotificationChannelRequest,
        DisableNotificationChannelResponse
      >,
      callback: grpc_1.sendUnaryData<DisableNotificationChannelResponse>,
    ): void
    abstract EnableNotificationCategory(
      call: grpc_1.ServerUnaryCall<
        EnableNotificationCategoryRequest,
        EnableNotificationCategoryResponse
      >,
      callback: grpc_1.sendUnaryData<EnableNotificationCategoryResponse>,
    ): void
    abstract DisableNotificationCategory(
      call: grpc_1.ServerUnaryCall<
        DisableNotificationCategoryRequest,
        DisableNotificationCategoryResponse
      >,
      callback: grpc_1.sendUnaryData<DisableNotificationCategoryResponse>,
    ): void
    abstract GetNotificationSettings(
      call: grpc_1.ServerUnaryCall<
        GetNotificationSettingsRequest,
        GetNotificationSettingsResponse
      >,
      callback: grpc_1.sendUnaryData<GetNotificationSettingsResponse>,
    ): void
    abstract UpdateUserLocale(
      call: grpc_1.ServerUnaryCall<UpdateUserLocaleRequest, UpdateUserLocaleResponse>,
      callback: grpc_1.sendUnaryData<UpdateUserLocaleResponse>,
    ): void
    abstract AddPushDeviceToken(
      call: grpc_1.ServerUnaryCall<AddPushDeviceTokenRequest, AddPushDeviceTokenResponse>,
      callback: grpc_1.sendUnaryData<AddPushDeviceTokenResponse>,
    ): void
    abstract RemovePushDeviceToken(
      call: grpc_1.ServerUnaryCall<
        RemovePushDeviceTokenRequest,
        RemovePushDeviceTokenResponse
      >,
      callback: grpc_1.sendUnaryData<RemovePushDeviceTokenResponse>,
    ): void
    abstract UpdateEmailAddress(
      call: grpc_1.ServerUnaryCall<UpdateEmailAddressRequest, UpdateEmailAddressResponse>,
      callback: grpc_1.sendUnaryData<UpdateEmailAddressResponse>,
    ): void
    abstract RemoveEmailAddress(
      call: grpc_1.ServerUnaryCall<RemoveEmailAddressRequest, RemoveEmailAddressResponse>,
      callback: grpc_1.sendUnaryData<RemoveEmailAddressResponse>,
    ): void
    abstract HandleNotificationEvent(
      call: grpc_1.ServerUnaryCall<
        HandleNotificationEventRequest,
        HandleNotificationEventResponse
      >,
      callback: grpc_1.sendUnaryData<HandleNotificationEventResponse>,
    ): void
  }
  export class NotificationsServiceClient extends grpc_1.makeGenericClientConstructor(
    UnimplementedNotificationsServiceService.definition,
    "NotificationsService",
    {},
  ) {
    constructor(
      address: string,
      credentials: grpc_1.ChannelCredentials,
      options?: Partial<grpc_1.ChannelOptions>,
    ) {
      super(address, credentials, options)
    }
    ShouldSendNotification: GrpcUnaryServiceInterface<
      ShouldSendNotificationRequest,
      ShouldSendNotificationResponse
    > = (
      message: ShouldSendNotificationRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<ShouldSendNotificationResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<ShouldSendNotificationResponse>,
      callback?: grpc_1.requestCallback<ShouldSendNotificationResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.ShouldSendNotification(message, metadata, options, callback)
    }
    EnableNotificationChannel: GrpcUnaryServiceInterface<
      EnableNotificationChannelRequest,
      EnableNotificationChannelResponse
    > = (
      message: EnableNotificationChannelRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<EnableNotificationChannelResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<EnableNotificationChannelResponse>,
      callback?: grpc_1.requestCallback<EnableNotificationChannelResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.EnableNotificationChannel(message, metadata, options, callback)
    }
    DisableNotificationChannel: GrpcUnaryServiceInterface<
      DisableNotificationChannelRequest,
      DisableNotificationChannelResponse
    > = (
      message: DisableNotificationChannelRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<DisableNotificationChannelResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<DisableNotificationChannelResponse>,
      callback?: grpc_1.requestCallback<DisableNotificationChannelResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.DisableNotificationChannel(message, metadata, options, callback)
    }
    EnableNotificationCategory: GrpcUnaryServiceInterface<
      EnableNotificationCategoryRequest,
      EnableNotificationCategoryResponse
    > = (
      message: EnableNotificationCategoryRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<EnableNotificationCategoryResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<EnableNotificationCategoryResponse>,
      callback?: grpc_1.requestCallback<EnableNotificationCategoryResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.EnableNotificationCategory(message, metadata, options, callback)
    }
    DisableNotificationCategory: GrpcUnaryServiceInterface<
      DisableNotificationCategoryRequest,
      DisableNotificationCategoryResponse
    > = (
      message: DisableNotificationCategoryRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<DisableNotificationCategoryResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<DisableNotificationCategoryResponse>,
      callback?: grpc_1.requestCallback<DisableNotificationCategoryResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.DisableNotificationCategory(message, metadata, options, callback)
    }
    GetNotificationSettings: GrpcUnaryServiceInterface<
      GetNotificationSettingsRequest,
      GetNotificationSettingsResponse
    > = (
      message: GetNotificationSettingsRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<GetNotificationSettingsResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<GetNotificationSettingsResponse>,
      callback?: grpc_1.requestCallback<GetNotificationSettingsResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.GetNotificationSettings(message, metadata, options, callback)
    }
    UpdateUserLocale: GrpcUnaryServiceInterface<
      UpdateUserLocaleRequest,
      UpdateUserLocaleResponse
    > = (
      message: UpdateUserLocaleRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<UpdateUserLocaleResponse>,
      options?: grpc_1.CallOptions | grpc_1.requestCallback<UpdateUserLocaleResponse>,
      callback?: grpc_1.requestCallback<UpdateUserLocaleResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.UpdateUserLocale(message, metadata, options, callback)
    }
    AddPushDeviceToken: GrpcUnaryServiceInterface<
      AddPushDeviceTokenRequest,
      AddPushDeviceTokenResponse
    > = (
      message: AddPushDeviceTokenRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<AddPushDeviceTokenResponse>,
      options?: grpc_1.CallOptions | grpc_1.requestCallback<AddPushDeviceTokenResponse>,
      callback?: grpc_1.requestCallback<AddPushDeviceTokenResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.AddPushDeviceToken(message, metadata, options, callback)
    }
    RemovePushDeviceToken: GrpcUnaryServiceInterface<
      RemovePushDeviceTokenRequest,
      RemovePushDeviceTokenResponse
    > = (
      message: RemovePushDeviceTokenRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<RemovePushDeviceTokenResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<RemovePushDeviceTokenResponse>,
      callback?: grpc_1.requestCallback<RemovePushDeviceTokenResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.RemovePushDeviceToken(message, metadata, options, callback)
    }
    UpdateEmailAddress: GrpcUnaryServiceInterface<
      UpdateEmailAddressRequest,
      UpdateEmailAddressResponse
    > = (
      message: UpdateEmailAddressRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<UpdateEmailAddressResponse>,
      options?: grpc_1.CallOptions | grpc_1.requestCallback<UpdateEmailAddressResponse>,
      callback?: grpc_1.requestCallback<UpdateEmailAddressResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.UpdateEmailAddress(message, metadata, options, callback)
    }
    RemoveEmailAddress: GrpcUnaryServiceInterface<
      RemoveEmailAddressRequest,
      RemoveEmailAddressResponse
    > = (
      message: RemoveEmailAddressRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<RemoveEmailAddressResponse>,
      options?: grpc_1.CallOptions | grpc_1.requestCallback<RemoveEmailAddressResponse>,
      callback?: grpc_1.requestCallback<RemoveEmailAddressResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.RemoveEmailAddress(message, metadata, options, callback)
    }
    HandleNotificationEvent: GrpcUnaryServiceInterface<
      HandleNotificationEventRequest,
      HandleNotificationEventResponse
    > = (
      message: HandleNotificationEventRequest,
      metadata:
        | grpc_1.Metadata
        | grpc_1.CallOptions
        | grpc_1.requestCallback<HandleNotificationEventResponse>,
      options?:
        | grpc_1.CallOptions
        | grpc_1.requestCallback<HandleNotificationEventResponse>,
      callback?: grpc_1.requestCallback<HandleNotificationEventResponse>,
    ): grpc_1.ClientUnaryCall => {
      return super.HandleNotificationEvent(message, metadata, options, callback)
    }
  }
}
